#include <iostream>
#include <type_traits>
#include <sstream> //for string to stream convs

  <% if (ctx.init){ %>
  #define UAPI_HAS_PROXY 1
  <% }%>
  namespace reflect{
  namespace proxy{


  <% if (ctx.init){ %>

  struct ProxySetter{};

  struct MemberContainer{
  virtual void memberModifiedCb(const std::string & memberName,variants::AnyMemberRefVar member,ProxySetter*from)=0;
  };
  template<typename T>
    struct MemberImpl{
    MemberImpl(const std::string & _name,T& _obj,MemberContainer &_container):name(_name),obj(_obj),container(_container){}
    const T& get()const {return obj;}
    void set(const T& o,ProxySetter* from=nullptr){obj = o;notify(from);}
    void notify(ProxySetter* from){container.memberModifiedCb(name,variants::AnyMemberRefVar(obj),from);}
    std::string name;
    T& obj;
    MemberContainer &container;
  };


  struct MethodCallInfo{
  template<typename T>
    MethodCallInfo(const std::string & fn,T argTuple) : funcName(fn),args(argTuple){}
    virtual ~MethodCallInfo() = default;
    //virtual void to_bin(std::ostream &oss) = 0;
    void to_bin(std::ostream &oss) {
    reflect::serialize::write_value(oss,funcName);
    reflect::serialize::write_value(oss,args);
    }
    std::string funcName;
    variants::AnyMethodArgsValue args;
  };


  <% } %>
  struct <%-name%>Proxy :protected MemberContainer{
  <%-name%>Proxy(<%-name%> & o):obj(o)
  <% for(const m of members){ -%>
  ,<%=m.name%>("<%=m.name%>",obj.<%=m.name%>,*this)
  <% } //endfor -%>
  {};


  std::function<void(const std::string & name,variants::AnyMemberRefVar member,ProxySetter*from)>onMemberChange;
  void memberModifiedCb(const std::string & memberName,variants::AnyMemberRefVar memberVal,ProxySetter*from)override{
  if(onMemberChange){
  onMemberChange(memberName,memberVal,from);
  }
  };
  std::function<void(MethodCallInfo* method,ProxySetter*from)>onMethodCall;
    void methodCalledCb(MethodCallInfo * callInfo,ProxySetter *from){
    if(onMethodCall){
    onMethodCall(callInfo,from);
    }
    }
    // Members
    <%-name%> & obj;
    <% for(const m of members){ -%>
    MemberImpl<<%-m.type%>> <%=m.name%>;
    <% } //endfor -%>

    <% for(const f of methods){ -%>
    virtual void <%=f.name%>(<%-f.getFunctionArgsWithVariables()%> <% if(f.hasArgs()) {%>,<% } %>
    ProxySetter* from=nullptr){
    MethodCallInfo info("<%=f.name%>",
    <% if(f.hasArgs()) {-%>
    <%-"std::make_tuple("+f.getArgVarNames().join(",")+")"-%>
    <% }else { -%>
    variants::VoidArgs()
    <% } -%>
    );
    methodCalledCb(&info,from);
    // todo full function passing

    }
    <% } //endfor -%>
  };


}
}
